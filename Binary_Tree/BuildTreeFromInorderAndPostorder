#include <bits/stdc++.h>
using namespace std;

/*
    Definition of a binary tree node
*/
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;

    TreeNode(int x) {
        val = x;
        left = nullptr;
        right = nullptr;
    }
};

/*
    Map to store:
    node value -> its index in inorder traversal

    This allows us to find where the root appears in inorder
    in O(1) time instead of scanning the array repeatedly.
*/
unordered_map<int, int> mp;

/*
    build(...) means:
    Construct the subtree formed by:
    inorder[inStart ... inEnd]
    postorder[postStart ... postEnd]
*/
TreeNode* build(vector<int>& inorder, vector<int>& postorder,
                int inStart, int inEnd,
                int postStart, int postEnd)
{
    /*
        If there are no elements left in either traversal,
        this subtree does not exist
    */
    if (inStart > inEnd || postStart > postEnd)
        return nullptr;

    /*
        Postorder traversal order is:
        Left → Right → Root

        So the LAST element in current postorder range
        is always the ROOT of this subtree
    */
    int rootVal = postorder[postEnd];
    TreeNode* root = new TreeNode(rootVal);

    /*
        Find the root position in inorder traversal.
        Inorder is:
        Left → Root → Right
    */
    int k = mp[rootVal];

    /*
        Number of nodes in left subtree
    */
    int leftSize = k - inStart;

    /*
        Left subtree is built from:
        inorder   : inStart → k - 1
        postorder : postStart → postStart + leftSize - 1
    */
    root->left = build(inorder, postorder,
                       inStart, k - 1,
                       postStart, postStart + leftSize - 1);

    /*
        Right subtree is built from:
        inorder   : k + 1 → inEnd
        postorder : postStart + leftSize → postEnd - 1
        (postEnd is the root, so we exclude it)
    */
    root->right = build(inorder, postorder,
                        k + 1, inEnd,
                        postStart + leftSize, postEnd - 1);

    return root;
}

/*
    This function starts the construction process
*/
TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder)
{
    /*
        Store inorder value → index
        This allows fast root lookups
    */
    for (int i = 0; i < inorder.size(); i++) {
        mp[inorder[i]] = i;
    }

    return build(inorder, postorder,
                 0, inorder.size() - 1,
                 0, postorder.size() - 1);
}

/*
    Preorder traversal to verify the constructed tree
*/
void printPreorder(TreeNode* root) {
    if (!root) return;
    cout << root->val << " ";
    printPreorder(root->left);
    printPreorder(root->right);
}

int main() {
    int n;
    cout << "Enter number of nodes: ";
    cin >> n;

    vector<int> inorder(n), postorder(n);

    cout << "Enter inorder traversal:\n";
    for (int i = 0; i < n; i++)
        cin >> inorder[i];

    cout << "Enter postorder traversal:\n";
    for (int i = 0; i < n; i++)
        cin >> postorder[i];

    TreeNode* root = buildTree(inorder, postorder);

    cout << "\nPreorder traversal of constructed tree:\n";
    printPreorder(root);

    return 0;
}
